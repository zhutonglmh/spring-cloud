**时间复杂度**

    算法的时间复杂度，用来度量算法的运行时间，记作：T(n) = O(F(n))。
    它表示随着输入大小n的增大，算法执行需要的时间的增长速度。

    O(1) 常数阶 < O(logn) 对数阶 < O(n) 线性阶 < O(nlogn) < O(n^2) 平方阶 < O(n^3) < { O(2^n) < O(n!) < O(n^n) }
    
    最后三项用大括号把他们括起来是想要告诉大家，如果日后大家设计的算法推导出的“大O阶”是大括号中的这几位，那么趁早放弃这个算法，
    在去研究新的算法出来吧。因为大括号中的这几位即便是在 n 的规模比较小的情况下仍然要耗费大量的时间，算法的时间复杂度大的离谱，基本上就是“不可用状态”。

    如何推导大o阶呢？我们给出了下面 的推导方法：
    执行总次数 = 1 + (n + 1) + n*(n + 1) + n*n + (n + 1) + 1 = 2n2 + 3n + 3
    用常数1取代运行时间中的所有加法常数。
    在修改后的运行次数函数中，只保留最髙阶项。
    如果最高阶项存在且不是1,则去除与这个项相乘的常数。
    按照上面推导“大O阶”的步骤我们先来第一步：“用常数 1 取代运行时间中的所有加法常数”，则上面的算式变为：执行总次数 = 2n^2 + 3n + 1
    
    第二步：“在修改后的运行次数函数中，只保留最高阶项”。这里的最高阶是 n 的二次方，所以算式变为：执行总次数 = 2n^2
    
    第三步：“如果最高阶项存在且不是 1 ，则去除与这个项相乘的常数”。这里 n 的二次方不是 1 所以要去除这个项的相乘常数，算式变为：执行总次数 = n^2
    
    因此最后我们得到上面那段代码的算法时间复杂度表示为： O( n^2 )
    
    最后我们在把常见的算法时间复杂度以及他们在效率上的高低顺序记录在这里，是大家对算法的效率有个直观的认识。
    O(1) 常数阶 < O(logn) 对数阶 < O(n) 线性阶 < O(nlogn) < O(n^2) 平方阶 < O(n^3) < { O(2^n) < O(n!) < O(n^n) }

**空间复杂度**

    空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。比如直接插入排序的时间复杂度是O(n^2),空间复杂度是O(1) 。
    而一般的递归算法就要有O(n)的空间复杂度了，因为每次递归都要存储返回信息。一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面衡量。
    
    计算方式与时间复杂度类似。

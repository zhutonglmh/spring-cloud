**同步、异步、阻塞、非阻塞**

    同步：两个同步任务互相依赖，并且一个任务必须依赖另一任务的某种方式执行。比如A->B事件中，你需要先完成A再完成B。
        当你同步执行某项任务时，你需要等待其完成才能继续执行其他任务。当你异步执行某些操作时，你可以在完成另一个任务之前继续进行
    异步： 两个异步的任务完全独立的，一方的执行不需要等待另外一方的执行。再换句话说，异步调用种一调用就返回结果不需要等待结果返回，
        当结果返回的时候通过回调函数或者其他方式拿着结果再做相关事情，
    阻塞： 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。
    非阻塞： 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。

**如何区分 “同步/异步 ”和 “阻塞/非阻塞” 呢？**

    同步/异步是从行为角度描述事物的，而阻塞和非阻塞描述的当前事物的状态（等待调用结果时的状态）。

BIO(同步阻塞IO)

    使用ServerSocket绑定IP地址和监听端口，客户端发起连接，通过三次握手建立连接，用socket来进行通信，通过输入输出流的方式来进行同步阻塞的通信
    
    每次客户端发起连接请求，都会启动一个线程
    
    线程数量：客户端并发访问数为1：1，由于线程是JAVA虚拟机中非常宝贵的资源，一旦线程数急剧增加，系统性能会急剧下降，导致线程栈溢出，创建新的线程失败，并最终导致宕机
    
    所以在JDK1.4之前，人们想到了一种方法，即PIO方式

PIO(伪异步阻塞IO)

    使用线程池来处理客户端的请求
    
    客户端个数：线程池最大线程数=M：N，其中M远大于N
    
    在read和write的时候，还是IO阻塞的，只是把每个线程交由线程池来控制管理
    
NIO（同步非阻塞IO）

    用NIO方式处理IO
    
    使用多路复用器Selector来轮询每个通道Channel，当通道中有事件时就通知处理，不会阻塞
    
    使用相当复杂
    
AIO（真正的异步非阻塞IO）

    NIO2.0引入了新的异步通道的概念，不需要使用多路复用器（Selector）对注册通道进行轮询即可实现异步读写，从而简化了NIO编程模型
    
四种IO的功能和特性对比

    有一个经典的举例。烧开水。钓鱼，两阶段  1、有没有鱼上钩   2、把鱼装进鱼篓
    假设有这么一个场景，有一排水壶（客户）在烧水。
    
    AIO的做法是，每个水壶上装一个开关，当水开了以后会提醒对应的线程去处理。
    NIO的做法是，叫一个线程不停的循环观察每一个水壶，根据每个水壶当前的状态去处理。
    BIO的做法是，叫一个线程停留在一个水壶那，直到这个水壶烧开，才去处理下一个水壶。

    --------------------------------------------------------------------------------------------------------------------------------------
                        |    同步阻塞I/O(BIO) |    伪异步阻塞I/0(PIO)   |    非阻塞I/O(NIO)   |    异步非阻塞I/0(AIO)
    --------------------------------------------------------------------------------------------------------------------------------------
                        |                     |                         |          M:1        |
    客户端个数:I/O线程  |       1:1           |    M:N(其中M可以大于N)  |  一个I/0线程处理    |   M:0 (不需要启动额外的I/O线程，
                        |                     |                         |  多个客户端连接     |   被动回调)
    --------------------------------------------------------------------------------------------------------------------------------------
      I/0 类型          |      阻塞I/0        |        阻塞I/0          |      非阻塞I/O      |     非阻塞I/O
    --------------------------------------------------------------------------------------------------------------------------------------
      I/0 类型          |      同步I/O        |        同步I/O          | 同步I/O(I/O)多路复用|      异步I/O
    --------------------------------------------------------------------------------------------------------------------------------------
      API 使用难度      |      简单           |        简单             |     非常复杂        |      复杂
    --------------------------------------------------------------------------------------------------------------------------------------
      调试难度          |      简单           |        简单             |       复杂          |      复杂
    --------------------------------------------------------------------------------------------------------------------------------------
      可靠性            |      非常差         |          差             |        高           |      高
    --------------------------------------------------------------------------------------------------------------------------------------
      吞吐量            |        低           |          中             |        高           |      高
    --------------------------------------------------------------------------------------------------------------------------------------
        
使用Netty框架进行编程步骤

    1、构建事件处理池
    
    2、使用引导程序关联事件处理池、通道、事件处理器
    
    3、绑定端口服务
    
    4、等待操作完成
    
    5、关闭事件处理池
    
同步：

    所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。
    例如普通B/S模式（同步）：提交请求->等待服务器处理->处理完毕返回 这个期间客户端浏览器不能干任何事

异步：

    异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。
    例如 ajax请求（异步）: 请求通过事件触发->服务器处理（这是浏览器仍然可以作其他事情）->处理完毕

阻塞：

    阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。

    有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回,它还会抢占cpu去执行其他逻辑，也会主动检测io是否准备好。

非阻塞：

    非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。
    
    再简单点理解就是：

    1. 同步，就是我调用一个功能，该功能没有结束前，我死等结果。
    2. 异步，就是我调用一个功能，不需要知道该功能结果，该功能有结果后通知我（回调通知）。
    3. 阻塞，就是调用我（函数），我（函数）没有接收完数据或者没有得到结果之前，我不会返回。
    4. 非阻塞，就是调用我（函数），我（函数）立即返回，通过select通知调用者

同步IO和异步IO的区别就在于：数据拷贝的时候进程是否阻塞

阻塞IO和非阻塞IO的区别就在于：应用程序的调用是否立即返回

综上可知，同步和异步,阻塞和非阻塞,有些混用,其实它们完全不是一回事,而且它们修饰的对象也不相同。


**NIO**
    NIO是一种同步非阻塞的I/O模型，在Java1.4中引入了NIO框架，对应java.nio包，提供了Chanel、Selector、Buffer等抽象。
    NIO中的N 可以理解为Non-Blocking，不单纯是new，它支持面向缓冲的，基于通道的I/O操作方法，NIO提供了与传统BIO模型中的Socket 和
    ServerSocket 相对应的SocketChanel 和ServerSocketChanel 两种不同的套接字通道实现，两种通道都支持阻塞与非阻塞两种模式，阻塞模式使用
    就像传统中的支持一样，比较简单，但是性能和可靠性都不好;非阻塞模式正好与之相反，对于低负载，低并发的应用程序，可以使用同步阻塞I/O来提升
    开发速率和更好的维护性；对于高负载，高并发的网络应用，应使用NIO的非阻塞模式来开发。 


**NIO的特性 NIO与IO的区别**
    
    如何回答：首先从NIO流是阻塞IO,而IO流是阻塞IO说起，然后可以从NIO的三个核心组件/特性为NIO带来的一些改进分析
    
    1、NIO流是非阻塞流，而IO流是阻塞IO。
        因为NIO是从通道Chanel中读取数据到buffer,同时可以做其他事情，当数据读取到buffer，线程再继续处理数据。写数据也是一样的。另外
        非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。
        
        java IO 的各种流是阻塞的，这意味着，当一个线程调用read()或者write时，该线程被阻塞，直到有一些数据被读取，或数据完全斜土。该线程在此期间不能
        再干任何事情了
        
     2、Buffer 缓冲区
     
        IO 面向流 Stream，而NIO面向缓冲区buffer
        
        Buffer 是一个对象，它包含一些要写入和要读出的数据。在NIO类库中加入BUffer对象，体现了新库与原I/O的一个重要区别。
        在面向流的I/O中，可以将数据直接写入或者将数据直接读到Stream对象中，虽然Stream 也有Buffer开头的拓展类，但只是流的包装类，还是从流
        读到缓冲区，而NIO却是直接读到buffer中操作。
        
        在NIO的库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区；在写入数据时，写入到缓冲区中，任何时候访问NIO中的数据，都是通过缓冲区
        进行操作的。
     
     3、Chanel(通道)
     
        NIO 通过Chanel(通道) 进行读写。
        通道是双向的，可读也可写，而流的读写是单向的，通道只能和Buffer交互，因为Buffer,通道可以一步的读写。
        
     4、Selector
     
        NIO有选择器，而IO没有。
        选择器用于使用单个线程处理多个通道，因此它需要较少的线程来处理这些通道。线程之间的切换对于操作系统来说是昂贵的。因此，为了提高系统效率
        选择器是有用的。





















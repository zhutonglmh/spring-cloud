**何为进程**

    进程是程序的一次执行过程，是系统运行程序的基本单位，一个程序的运行就是一个进程创建、运行、消亡的过程。
    
**何为程序**

    程序就是包含了二进制指令了数据的静态文件。
    
**何为线程**

    线程与进程类似，但线程是一个比进程更小的单位，一个进程在运行过程中可以产生多个线程，
    与进程不同的是，多个线程共享堆和方法区的资源，但每个线程都有自己的程序计数器、虚拟机栈，
    和方法栈，所以系统产生一个线程，或是在各个线程之间切换的时候，负担要比进程小的多，也正因为如此
    ，线程被称为轻量级进程。
    
**线程和进程之间的关系**

    线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各线程之间都是互相独立的，而各线程则不一样，因为同一进程中的线程之间会相互影响。
    线程执行开销小，但是不利于资源的管理和维护，而进程正相反
    
    
**程序计数器为什么是私有的？**

    程序计数器的作用有两个：
        1、字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理等
        2、在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次执行的地方。
     程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。
     
**虚拟机栈和本地方法栈为什么是私有的？**

    虚拟机栈：
        每个java方法在执行的同事会创建一个栈帧用于存储局部变量表、操作数栈，常量池引用等信息
        ，从方法调用直至完成的过程，就对应着一个栈帧在java虚拟机中出栈与入栈的过程。
    本地方法栈：
        和虚拟机栈发挥的作用非常相似，区别是虚拟机栈执行java方法，本地方法栈执行本地native方法，
        在hotspot 虚拟机中   本地方法栈 和 java虚拟机栈合二为一。
        
**一句话了解堆和方法区**

    堆和方法区是所有线程共享的资源，之中堆是进程中最大的一块内存，主要用于存放新对象(所有的对象都在这里分配内存)，方法区主要存储的是
    已被加载的类信息，常量，静态变量、即时编译器编译后的代码和数据。
    
**说说并发和并行的区别**

    并发: 同一时间段，多个任务在同时执行(单位时间内不一定同时执行，看cpu分片)
    并行：单位时间内，多个任务在同时进行。
    
**为什么要使用多线程呢**

    1、从计算机底层来说：线程可以比作轻量级进程，是程序执行的最小单位，线程间的切换和调度的成本远远小于进程，另外，多核cpu时代意味着多个线程可以
    同时运行，这减少了线程切换上下文的开销。
    2、从当代互联网的发展趋势来说：现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大
    地提高系统整体的并发能力以及性能。
    3、单核时代：
        在单核系统的时代，多线程主要是为了提高cpu 和 io 设备的利用率。举个例子 只有一个线程的时候  可能导致 cpu计算时io设备空闲，io 设备操作时dpu空闲。
    4、多核时代
        多核时代多线程主要是为了提高cpu利用率。举个例子，假如我们要计算一个复杂的任务，单线程的话只有一个cpu核心会被使用到，多线程可以使多个cpu核心都可以被使用到
        
**使用多线程可能会带来什么问题**

    1、死锁问题
    
    2、线程的上下文切换
    
    3、内存泄漏
    
    4、受限于硬件和软件的资源闲置
    
**说说线程的生命周期和状态**

    1、NEW             线程被创建，但是还没有调用start方法
    2、RUNABLE         运行状态，java中将运行状态 和 就绪状态 统称为 运行中
    3、BLOCKED         阻塞状态，表示线程阻塞于锁
    4、WAITING         等待状态，表示线程进入等待状态，需要等待特定的通知才可以进行下一步动作
    5、TIME-WAITING    超时等待状态，表示线程进入等待状态，一定时间后恢复正常
    6、TERMINATED      终止状态，表示当前线程已经执行完毕
    
**什么是上线文切换**

    cpu采取的策略为为每一个线程分配时间片轮换的形式，当一个线程用完时间片后就会重新进入就绪状态，让给其他线程使用，这个过程就属于一次上下文切换。
    linux 下 一个优点就是 ，其上下文切换比其他的系统时间消耗少很多。
    
**什么是线程死锁**

    多个线程同时被阻塞，它们中的一个或者全部都在等耨个资源被释放。由于线程被无限期阻塞，因此程序不可能正常终止。
    如:  线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。
    
**死锁产生的必要条件**

    1、互斥条件
    2、请求与保持条件
    3、不剥夺条件
    4、循环等待条件
    
**如何避免死锁**

    1、破坏互斥条件                    这个条件我们没办法破坏，因为我们用锁就是想让它们互斥的
    2、破坏请求与保持条件              一次性申请所有资源
    3、破坏不剥夺条件                  占用部分资源的线程进一步申请其他资源时，如果申请不到，主动释放自己占有的资源。
    4、破坏循环等待条件                靠按序申请资源来预防，按照某一顺序来请求资源，释放资源
    
**说说sleep() 方法和 wait() 方法区别和共同点**

    两者最主要的区别是  
    1、    sleep 方法不会释放锁   wait 方法会释放锁
    2、wait 通常被用于线程间交互/通信，sleep 通常被用于暂停。
    3、wait 方调用后，线程不会自动苏醒，需要别的线程上调用同一个对象的notif方法或者调用notifyall 方法
       sleep 方法执行完成后，线程会自动苏醒，或者可以使用wait(long timeout) 后线程会自动苏醒。
       
**为什么我们调用start方法时会执行run方法，为什么我们不能直接调用run方法**

    new 一个 Thread ,线程进入了新建状态；调用start方法，会启动一个线程并使线程进入到了就绪状态，当分配时间片后就可以开始运行了。start会执行线程的
    相应装备工作，然后自动执行run方法中的内容，这是真正的多线程工作。而直接执行run方法，会把run方法当做一个mian线程下的普通方法去执行，并不会在某个
    线程之中执行它，所以这并不是多线程工作。
    
**synchronize 关键字**

    synchronize 关键字解决的是多个线程之间访问资源的同步性，synchroize 关键字可以保证被它修饰的方法或者代码块在任意时刻只有一个线程执行。
    在java 早期版本，synchronize 属于重量级锁，jdk 1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来
    减少锁操作的开销。
    
**说说你自己是怎样使用synchronize的**

    synchronize 关键字最主要的三种使用方法
    
    1、修饰静态方法                  
        也就是给当前类加锁，因为静态成员不属于任何一个实例对象，是类成员制
        所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，
        不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。
    2、修饰实例方法                   作用于当前对象加锁
    3、修饰代码块                     指定加锁对象，对给定对象加锁，进入同步代码块要获得给定对象的锁。
    
    实现：双重校验实现对象单例
    
**锁主要的状态**

    1、无锁状态
    2、偏向锁状态
    3、轻量级锁状态
    4、重量级锁状态
    
    他们会随着竞争的激烈而逐渐升级，注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。
    
    1、偏向锁
        引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了没有多线程竞争的前提下，较少传统的轻量级锁使用操作系统互斥量产生的性能消耗。
        但是不同的是：轻量级锁在无竞争的情况下使用cas 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉。
        
        偏向锁的“偏“就是偏心的偏，它的意思是会偏向于第一个获得它的进程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要
        进行同步！
        但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样的场合可能每次申请锁的线程都是不同的，因此在这种场合下不应该使用偏向锁，否则会得不偿失
        ，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。
        
    2、轻量级锁
    
        倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段。轻量级锁不是为了代替重量级锁，它的本意是在没有多线程
        竞争的前提下，减少传统的重量级锁使用操作系统互斥产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量，另外轻量级锁的加锁和解锁都用到了cas操作。
        轻量级锁能够提升程序同步性能的依据是“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，
        轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，
        轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！
        
    3、自旋锁与自适应自旋   
    
        轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。
        互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态来完成(用户态转换到内核态会耗费时间)。
        一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间而去把线程挂起/恢复 是得不偿失的，所以，虚拟机的开发团队就这样去考虑：“
        我们能不能让后面的请求获取锁的线程等待一会而不会被挂起呢？看看持有锁的线程是否很快就会释放锁”。为了让一个线程等待，我们只需要让线程执行一个
        忙循环(自旋)，这项技术就叫做自旋。
        
        自旋锁在 JDK1.6 之前其实就已经引入了，不过是默认关闭的，需要通过--XX:+UseSpinning参数来开启。JDK1.6及1.6之后，就改为默认开启的了。需要注意的是：自旋等待不能完全替代阻塞，因为它还是要占用处理器时间。如果锁被占用的时间短，那么效果当然就很好了！反之，相反！自旋等待的时间必须要有限度。如果自旋超过了限定次数任然没有获得锁，就应该挂起线程。自旋次数的默认值是10次，用户可以修改--XX:PreBlockSpin来更改。
        
        另外,在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了。
        
    4、锁消除
    
        锁消除理解起来很简单，它指的是虚拟机及时编辑器在运行时，如果检测到哪些数据不可能存在竞争，那么就执行锁消除，锁消除可以节省毫无意义的请求锁的时间。
       
    5、锁粗化
    
        原则上，我们编写代码的时候，总是推荐将同步块的作用范围限制的足够小，只在共享数据的实际作用域才进行同步，这样是为了使得西药同步的操作数量尽可能变小
        ，如果存在锁竞争，那等待线程也可能尽快拿到锁。
        大部分情况下，上述的原则是没有问题的，但是如果一系列的连续操作都对同一个对象反复加锁与解锁，那么会带来很多不必要的消耗。
        
**synchronized 和 reenTrantLock 的区别**

    1、两者都是可重入锁
       
        可重入锁概念是，自己可以再次获取自己的内部锁。递归调用，内部通过计数器实现，同一个线程每次获取锁，锁的计数器加一，所以要等到锁的计数器为0的时候才释放锁。
    
    2、synchronized 依赖于jvm 而 reentrantlock 依赖于 api  
      
        synchronized 是依赖于jvm 实现的，前面也讲到了虚拟机团队在jdk1.6对synchronized关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有暴露给我们，
        
        reenTrantLock 是通过jdk层面实现的(也就是api层面，需要lock() 和 unlock() 方法配合try/finally语句块来完成)，
        我们可以查看它的源代码，来看它是怎么实现的。
        
    3、ReenTrantLock 比 synchronized 增加了一些高级功能
     
        1、等待可中断
        2、可实现公平锁；
        3、可实现选择性通知(锁可以绑定多个条件)
        
        4、性能已不是选择标准
        
     --ReenTrantLock 提供了一种能够中断等待锁的线程的机制，通过lock.lockInterrupibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情
     
     --ReenTrantLock 可以指定是公平锁还是非公平锁；而synchronized 只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。reenTrantLock 默认情况是非公平的，
     可以通过ReenTrantLock类的ReenTrantLock(boolean fial)构造方法来制定是否是公平的。
     
     --synchronized 关键字与wait() 和 notify()/notifyAll 方法相结合可以实现等待/通知机制，ReenTrantLock类当然也可以实现，但是需要借助Condition接口与new Condition()
     方法。Condition 是jdk1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个lock对象中可以创建多个Condition 实例(即对象监视器)，线程
     对象可以注册在指定的Condition中，从而可以有选择的进行线程通知，在调度线程上更加灵活。在使用notify/notifyAll方法进行通知时，被通知的线程是由jvm选择的，用ReenTrantLock类
     结合Condition实例可以实现"选择性通知"，这个功能非常重要，而且死Condition接口默认提供的，而synchronized 关键字就相当于整个Lock对象中只有一个Condition实例，
     所有的线程都注册在它一个身上，如果执行notifyAll就会通知所有处于等待状态的线程这样在成很大的效率问题，而Condition实例的signalAll()方法只会唤醒注册在改Condition 实例中的
     所有等待线程。
     
     总结：
     相同点：
     
            1、都能保证了线程安全性
     
            2、都支持锁的重入
     
     不同点：
     
           1、synchronized适用于不是很激烈的情况，reentranLock适用于比较竞争激烈的情况
     
           2、Synchronized是jvm层面实现的锁机制，而reentranLock是java代码层面实现的锁机制。
     
           3、Reentranlock比synchronized多了锁投票，定时锁，中断锁等机制
     
           4、synchronized是隐式获取锁和释放锁，不需要代码手动获取释放，Reentranlock为显示获取锁和释放锁，必须要手动代码获取释放
           
           
**volatile 关键字**

    一、讲一下内存模型
    

    原子性、
    
        即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
        在我们这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。
    假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。
    那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。
    
    
    可见性、
    
        可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
        
    有序性
        
        即程序执行的顺序按照代码的先后顺序执行
        
        
         程序  ----->  本地内存(如 寄存器等，cpu 三级缓存) ----> 主存(共享内存)
         
         jck1.2之前，java的内存模型总是从主存读取变量，是不需要特别注意的。

        1、为什么要有内存模型
            
            随着 CPU 技术的发展，CPU 的执行速度越来越快。
            
                而由于内存的技术并没有太大的变化，所以从内存中读取和写入数据的过程和 CPU 的执行速度比起来差距就会越来越大，这就导致 CPU 每次操作内存
            都要耗费很多等待时间。
            
                所以，人们想出来了一个好的办法，就是在 CPU 和内存之间增加高速缓存。 缓存的概念大家都知道，就是保存一份数据拷贝。它的特点是速度快，内存小，并且价格昂贵。
            那么，程序的执行过程就变成了：程序在运行过程中，会将运算需要的数据从主存复制一份到 CPU 的高速缓存当中。
                那么 CPU 进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。
         
         2、问题： 在不使用volatile关键字的情况下，有哪些情况会导致线程的工作内存失效，然后必须重新去读取主存的共享变量？
          
          1、线程中释放锁时(线程释放锁会强制刷写到主存，线程获取锁会强制从主存重新刷新变量值)
          
          2、线程切换时(当线程切换到其他线程，后来又切换到该线程的时候去重新读取)
          
          3、CPU有空闲时间时（比如线程休眠时,当执行该线程的cpu有空闲时，他会去主存读取一下共享变量的值来更新线程工作内存中的值）

        3、带来的问题
          当前内存模型下，线程可以吧变量保存在本地内存(比如机器的寄存器中)，而不是直接在内存中进行读写。这就可能造成一个线程在主存中修改了一个
           变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。
           
         4、解决方式
            使用valatile 关键字，这就指示jvm，这个变量是不稳定的，每次使用它都到内存中进行读取。实现方式(内存屏障)
            说白了就是保障变量的可见性，另一个作用是防止指令重排序。
    
    二、说说synchronized 和 valatile 关键字的区别
    
        **  volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
        **  volatile 关键字是线程同步的轻量级实现，所以volatile 的性能肯定比synchronized 关键字要好。
        **  但是volatile 关键字只能作用于变量，synchronized 还可以修饰方法和代码块。synchronized在jdk1.6引入了偏向锁，轻量级锁，自旋锁以及其他优化之后性能有了显著提升，
        实际开发中还是synchronized  关键字用到的多一些。
        **  多线程访问volatile关键字不会发生阻塞，synchronized关键字可能会发生阻塞
        **  volatile 关键字能保证数据的可见性、有序性，但不能保证数据的原子性，synchronized 关键字能保证原子性、可见性，但不能保证有序性。
        **  “被volatile关键字修饰的对象作为类变量或实例变量时，其对象中携带的类变量和实例变量也相当于被volatile关键字修饰了”。
        **   volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。(重排序)

    三、ThreadLocal
    
        1、ThreadLocal简介
            
            通常情况下，我们创建的变量是可以被任何一个线程访问修改的。如果我们想实现每个线程都有自己的专属本地变量，该如何解决呢？
            jdk 中提供了ThreadLocal 类正是为了解决这样的问题。ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子
            ，盒子中可以存储每个线程的私有数据。
        

        2、ThreadLocal 实现
        
            从上面Thread类 源代码可以看出Thread 类中有一个 threadLocals 和 一个 inheritableThreadLocals 变量，它们都是 ThreadLocalMap 类型的变量,
            我们可以把 ThreadLocalMap 理解为ThreadLocal 类实现的定制化的 HashMap。默认情况下这两个变量都是null，只有当前线程调用 ThreadLocal 类的
             set或get方法时才创建它们，实际上调用这两个方法的时候，我们调用的是ThreadLocalMap类对应的 get()、set()方法。

        3、ThreadLocal 内存泄漏问题
        
            ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时
            候，key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远
            无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清
            理掉 key 为 null 的记录。使用完 ThreadLocal方法后 最好手动调用remove()方法

        4、弱引用、软引用、强引用、虚引用(拓展知识)
            
            1．强引用
            
            以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。
            当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。
            
            2、软引用（SoftReference）
            
            如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。
            只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
            
            3、弱引用（WeakReference）
            
            如果一个对象只具有弱引用，那就类似于可有可物的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它
            所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，
            因此不一定会很快发现那些只具有弱引用的对象。
            
            4、虚引用（PhantomReference）
            
            “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，
            在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）
            联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过
            判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象
            的内存被回收之前采取必要的行动。

    四、线程池
        
            1、为什么要使用线程池
            池化技术相对大家来说已经屡见不鲜了，线程池，连接池，http 连接池等等都是对这个思想的应用。池化技术的思想主要是减少每次获取资源的消耗，提高
            对资源的利用率。
            
                1、减少获取资源、销毁资源的消耗
                    通过重复利用来减少线程创建和销毁造成的消耗。
                2、提高响应速度
                    当任务到达时，任务可以不需要到线程创建就可以执行
                3、提高线程的可管理性。
                    线程是稀缺资源，如果无限制的创建，不仅会消耗资源，还会降低系统的稳定性，使用线程池可以统一的分配、调优和监控。
                
            4.2 实现Runnable 接口 和 Callable 接口的区别
            
                1、Runnable 一直存在，但Callable仅在java1.5中引入，目的就是为了来处理Runnable 不支持的用例。
                Runnable 接口不可以抛出异常，Callable 接口可以。若依，如果任务不需要抛出异常推荐使用Runnable 接口，使代码看起来更加简洁。
                
            4.3 执行execute() 方法 和 submit()方法的区别是什么
             
                1、excute() 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否;
                2、submit() 方法用于提交需要返回值的任务。线程池会返回一个Future对象，通过这个Future 对象可以判断任务是否执行成功，并且可以使用
                Future 的 get 方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get(long time,TimeUnit unit)方法的话会阻塞当前线程一段时间后立即返回，
                这时候可能任务没有执行完。
                
            4.4 如何创建线程池
            
                阿里巴巴开发手册中不允许使用Executors 去创建，而是通过ThresdPoolExecutor 的方式，这样的处理方式让写的同学更贱明确线程池的运行规则，规避资源耗尽的风险。
                
                方法一：通过构造方法实现
                ThreadPoolExecutor 
                四个构造方法
                
                方法二：通过Executor 框架的工具类Executors 来实现，我们可以创建三种类型的ThreadPoolExecutors
                
                    1、FiedThreadPool：
                        该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终保持不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，
                        则新的任务会被暂存再一个任务队列中，带有线程空闲时，便处理在任务队列中的任务。
                    2、SingleThreadExecutor：
                        该方法返回只有一个线程的线程池，若多余一个任务被提交到线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。
                        
                    3、CachedThreadPool
                        该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲的线程可以复用，则会有限使用可复用的线程，若所有线程均在工作，
                        又有新的任务提交，则创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。
                        
            4.5 ThreadPoolExecutor 类中提供的四个构造方法
            
                ThreadPoolExecutor 3 个最重要的参数：
                
                1、corePoolSize : 核心线程数，线程数定义了最小可以同时运行的线程数量。
                2、maximumPoolSize ：当队列中存放的任务到达队列容量的时候，当前可以运行的线程数量变为最大线程数。
                3、workQueue：当新任务来到的时候会先判断当前运行的线程数量是否到达核心线程数，如果到达的话，新任务就会被存放在队列中。
                
                其他常见参数：
                1、keepAliveTime：当线程池中的线程数量大于corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，
                直到等待的时间超过了keepAliveTime 才会被回收销毁；
                2、unit : 时间单位
                3、threadFactory : executor 创建线程的时候会用到
                4、handle：饱和策略
                
             4.5.2 ThreadPoolExecutor 饱和策略
                
                如果线程池的等待队列已满，且已经到达最大同时运行线程数时，对于新提交的任务，线程池有四种策略
                
                1、抛出异常，来拒绝新任务的处理         ThreadPoolExecutor.AbortPolicy
                2、将新提交的任务放到主线程进行执行     ThreadPoolExecutor.CallerRunsPolicy
                3、不处理新任务，直接丢弃               ThreadPoolExecutor.DiscardPolicy
                4、丢弃最早的未处理任务请求。           ThreadPoolExecutor.DiscardOldestPolicy


    五、原子类
    
            1、介绍一下原子类
            
                Atomic 在我们这里Atomic 是指一个操作不可中断的。即使多个线程在一起执行，一个操作已经开始，就不会被其他的线程干扰。
                
                所以、所谓的原子类简单来说就是具有原子/原子操作特征的类。














**java 内存区域**
    
    jdk 8
    \----------------------------\--------------------------------\
    \      Native Method Stacks  \    Program Count Register      \
    \           本地方法栈       \           程序计数器           \
    \----------------------------\--------------------------------\
    \                        JVM Stacks                           \
    \                         虚拟机栈                            \
    \-------------------------------------------------------------\
    \         Heap(堆)      \     \    Metaspzce(元数据区) \      \
    \     eden \ s0 \ s1    \ old \   class类元信息\ code \
    \       young区(新生代) \     \      方法元信息        \ Cache\
    \--------------------------------------------------------------
    
**概述**
    
        对于程序员来说，在虚拟机自动内存管理下，不需要再像c/c++程序开发程序员那样控制内存。不容易出现内存泄漏
    和内存溢出问题。正是因为Java程序员把内存交给Java虚拟机，一旦出现内存泄漏和内存溢出，如果不了解虚拟机是怎样
    的使用内存的，那么排查错误将会是一个非常艰巨的任务。
    
**运行时数据区域**
    
        java虚拟机在执行java程序的过程中会把它管理的内存划分成若干个不同的数据区域。
        这些数据区域一些是线程私有的，其他的则是线程共享的。
        1、线程私有
        
            1、程序计数器
            2、本地方法栈
            3、虚拟机栈
            
        2、线程共有
        
            1、堆(1.7 之后的常量池在这里)
            2、元空间\永久代(方法元信息、类元信息)
            3、运行时常量池
            4、直接内存
            
**1、程序计数器**
    
        程序计数器是一块较小的空间，可以看做是当前线程所执行的字节码的行号指示器，
        字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复
    等功能都需要依赖这个计数器来完成。
        另外，为了线程切换后能够恢复到正确的执行位置，每一个线程都需要一个独立的程序计数器，各线程之间计数器互不影响，独立存储。
    我们称这类内存区域为线程私有的内存区域。    
    
        简述：
        1、字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
        2、在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。
    注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。
    
**2、java 虚拟机栈**

         与程序计数器一样，java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是java方法执行的内存模型，
         java 内存可以粗糙的分为堆(heap)内存和栈(stack)内存,其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量
      表部分。
        局部变量表主要存放了编译器可知的各种类型(byte、short、char、boolean、int、double、float、long)、对象引用
        (reference类型，它不同于对象本身，可能是一个执行对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他
        与此对象相关的位置)。
        
        java 虚拟机栈会出现两种异常：stackOverFlowError 和 OutOfMemoryError。
        
            StackOverFlowError： 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。
            OutOfMemoryError： 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。
         
         java 虚拟机栈也是线程私有的，每个线程有自己的java 虚拟机栈。而且随着线程的创建而创建，随着线程的消亡而死亡。
        
**3、本地方法栈**

        和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行java方法(也就是字节码)服务，而本地方法栈
    则为虚拟机使用到的native方法服务。在HotSpot中和java 虚拟机栈合二为一。
    
    本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。
    方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。
    
**4、堆**

    java 虚拟机所管理的内存中最大的一块，java堆是所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一
    目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。
    
    java堆是垃圾收集器管理的主要区域，因此也被称为GC堆，从垃圾回收的角度，由于现在收集器都采用分代垃圾收集算法，
    所以java堆还可以细分为：新生代和老年代，eden空间、survicor、to survitor 空间等。进一步划分的目的是更好地回收
    内存，或者更快的分配内存。
    
    在jdk1.8中移除整个永久代，取而代之的是一个叫元空间的区域(永久代使用的jvm的堆内存空间，而元空间使用的物理内存，
    直接受到本机的物理内存限制)。
    
**5、方法区**

        方法区与java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量。即时编译器
    编译后的代码等数据。虽然java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却又一个别名叫做 non-heap(非堆)，
    目的应该是与java 堆区分开来。
        hotspot 虚拟机中方法区也常称为"永久代"，本质上两者并不等价，仅仅是因为hotspot团队用永久代来实现方法区，
        但是这并不是一个好主意，jdk1.8 后扔到物理内存中去了。
        相对而言，垃圾收集行为在这个区域是很少出现的，但并非数据进入方法区后就永久存在了。
        
**6、运行时常量池**

        运行时常量池是方法区的一部分，class文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息(
        用于存放编译期生成的各种字面量和符号引用)。
       
       字面量：文本字符串、被声明为final的常量值、基本数据类型的值，其他
       
       jdk1.7之后的版本已经将运行时常量池从方法区移了出来，在java heap(堆)中开辟了一块区域存放运行时常量池。
       
**7、直接内存**
    
        直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁的使用。
        而且也可能导致OutOfMemoryError异常出现。
        
        jdk1.4 中新加入的nio(New Input/Output)类，引入了一种基于通道(channel)和缓存区(buffer)的I/O方式，然后通过一个
        存储在java 堆中的directByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著的提升性能，因为避免
        了在java 堆与 native 堆之间来回复制数据。
        
        本机直接内存的分配不会受到java堆的限制，但是会受到本机物理牛才能大小预计处理器寻址空间的限制。
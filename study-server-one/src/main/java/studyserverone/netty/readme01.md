BIO(同步阻塞IO)

    使用ServerSocket绑定IP地址和监听端口，客户端发起连接，通过三次握手建立连接，用socket来进行通信，通过输入输出流的方式来进行同步阻塞的通信
    
    每次客户端发起连接请求，都会启动一个线程
    
    线程数量：客户端并发访问数为1：1，由于线程是JAVA虚拟机中非常宝贵的资源，一旦线程数急剧增加，系统性能会急剧下降，导致线程栈溢出，创建新的线程失败，并最终导致宕机
    
    所以在JDK1.4之前，人们想到了一种方法，即PIO方式

PIO(伪异步阻塞IO)

    使用线程池来处理客户端的请求
    
    客户端个数：线程池最大线程数=M：N，其中M远大于N
    
    在read和write的时候，还是IO阻塞的，只是把每个线程交由线程池来控制管理
    
NIO（同步非阻塞IO）

    用NIO方式处理IO
    
    使用多路复用器Selector来轮询每个通道Channel，当通道中有事件时就通知处理，不会阻塞
    
    使用相当复杂
    
AIO（真正的异步非阻塞IO）

    NIO2.0引入了新的异步通道的概念，不需要使用多路复用器（Selector）对注册通道进行轮询即可实现异步读写，从而简化了NIO编程模型
    
四种IO的功能和特性对比

    有一个经典的举例。烧开水。
    假设有这么一个场景，有一排水壶（客户）在烧水。
    
    AIO的做法是，每个水壶上装一个开关，当水开了以后会提醒对应的线程去处理。
    NIO的做法是，叫一个线程不停的循环观察每一个水壶，根据每个水壶当前的状态去处理。
    BIO的做法是，叫一个线程停留在一个水壶那，直到这个水壶烧开，才去处理下一个水壶。

    --------------------------------------------------------------------------------------------------------------------------------------
                        |    同步阻塞I/O(BIO) |    伪异步阻塞I/0(PIO)   |    非阻塞I/O(NIO)   |    异步非阻塞I/0(AIO)
    --------------------------------------------------------------------------------------------------------------------------------------
                        |                     |                         |          M:1        |
    客户端个数:I/O线程  |       1:1           |    M:N(其中M可以大于N)  |  一个I/0线程处理    |   M:0 (不需要启动额外的I/O线程，
                        |                     |                         |  多个客户端连接     |   被动回调)
    --------------------------------------------------------------------------------------------------------------------------------------
      I/0 类型          |      阻塞I/0        |        阻塞I/0          |      非阻塞I/O      |     非阻塞I/O
    --------------------------------------------------------------------------------------------------------------------------------------
      I/0 类型          |      同步I/O        |        同步I/O          | 同步I/O(I/O)多路复用|      异步I/O
    --------------------------------------------------------------------------------------------------------------------------------------
      API 使用难度      |      简单           |        简单             |     非常复杂        |      复杂
    --------------------------------------------------------------------------------------------------------------------------------------
      调试难度          |      简单           |        简单             |       复杂          |      复杂
    --------------------------------------------------------------------------------------------------------------------------------------
      可靠性            |      非常差         |          差             |        高           |      高
    --------------------------------------------------------------------------------------------------------------------------------------
      吞吐量            |        低           |          中             |        高           |      高
    --------------------------------------------------------------------------------------------------------------------------------------
        
使用Netty框架进行编程步骤

    1、构建事件处理池
    
    2、使用引导程序关联事件处理池、通道、事件处理器
    
    3、绑定端口服务
    
    4、等待操作完成
    
    5、关闭事件处理池
    
同步：

    所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。
    例如普通B/S模式（同步）：提交请求->等待服务器处理->处理完毕返回 这个期间客户端浏览器不能干任何事

异步：

    异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。
    例如 ajax请求（异步）: 请求通过事件触发->服务器处理（这是浏览器仍然可以作其他事情）->处理完毕

阻塞：

    阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。

    有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回,它还会抢占cpu去执行其他逻辑，也会主动检测io是否准备好。

非阻塞：

    非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。
    
    再简单点理解就是：

    1. 同步，就是我调用一个功能，该功能没有结束前，我死等结果。
    2. 异步，就是我调用一个功能，不需要知道该功能结果，该功能有结果后通知我（回调通知）。
    3. 阻塞，就是调用我（函数），我（函数）没有接收完数据或者没有得到结果之前，我不会返回。
    4. 非阻塞，就是调用我（函数），我（函数）立即返回，通过select通知调用者

同步IO和异步IO的区别就在于：数据拷贝的时候进程是否阻塞

阻塞IO和非阻塞IO的区别就在于：应用程序的调用是否立即返回

综上可知，同步和异步,阻塞和非阻塞,有些混用,其实它们完全不是一回事,而且它们修饰的对象也不相同。